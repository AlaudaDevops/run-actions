name: AI PR Review

on:
  workflow_dispatch:
    inputs:
      repository:
        description: "Repository to review (owner/repo format)"
        required: true
        type: string
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string
      review_style:
        description: "Review style (strict, balanced, lenient)"
        required: false
        default: "strict"
        type: string
      dry_run:
        description: "Dry run mode (output review but don't post comments)"
        required: false
        default: false
        type: boolean

  workflow_call:
    inputs:
      repository:
        description: "Repository to review (owner/repo format)"
        required: true
        type: string
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string
      review_style:
        description: "Review style (strict, balanced, lenient)"
        required: false
        default: "strict"
        type: string
      dry_run:
        description: "Dry run mode (output review but don't post comments)"
        required: false
        default: false
        type: boolean
    secrets:
      TOKEN:
        description: "GitHub token with repo access"
        required: true
      KILO_API_KEY:
        description: "API key for the AI provider (e.g., Anthropic API key)"
        required: true

env:
  REVIEW_COMMENT_MARKER: "<!-- kilo-pr-review-comment -->"
  INLINE_COMMENT_MARKER: "<!-- ai-code-review-inline -->"
  SHARED_PROMPT_PATH: ".github/prompts/code-review.md"
  PERSONALIZED_PROMPT_PATH: ".github/prompts/pr-review.md"
  AI_MODEL: "mistralai/devstral-2512:free"

jobs:
  review-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout run-actions repo (for shared prompt)
        uses: actions/checkout@v4
        with:
          path: run-actions

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Install GitHub CLI
        uses: dev-hanz-ops/install-gh-cli-action@v0.2.1
        with:
          # current latest
          # https://github.com/cli/cli/releases/tag/v2.81.0
          gh-cli-version: 2.81.0

      - name: Auth with GitHub CLI
        run: |
          echo -n "${{ secrets.TOKEN }}" | gh auth login --with-token
          echo "‚úÖ GitHub CLI authenticated"

      - name: Validate PR exists
        id: validate-pr
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"

          echo "üîç Validating PR #$PR_NUMBER in $REPO..."

          # Get PR details including head SHA for check status
          PR_DATA=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json number,title,state,headRefName,baseRefName,author,additions,deletions,changedFiles,headRefOid 2>&1) || {
            echo "‚ùå Failed to fetch PR #$PR_NUMBER from $REPO"
            echo "Error: $PR_DATA"
            exit 1
          }

          echo "$PR_DATA" | jq .

          # Check if PR is open
          PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
          if [ "$PR_STATE" != "OPEN" ]; then
            echo "‚ö†Ô∏è PR #$PR_NUMBER is not open (state: $PR_STATE). Skipping review."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract PR info for later use
          echo "pr_title=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "pr_author=$(echo "$PR_DATA" | jq -r '.author.login')" >> $GITHUB_OUTPUT
          echo "head_branch=$(echo "$PR_DATA" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          echo "base_branch=$(echo "$PR_DATA" | jq -r '.baseRefName')" >> $GITHUB_OUTPUT
          echo "additions=$(echo "$PR_DATA" | jq -r '.additions')" >> $GITHUB_OUTPUT
          echo "deletions=$(echo "$PR_DATA" | jq -r '.deletions')" >> $GITHUB_OUTPUT
          echo "changed_files=$(echo "$PR_DATA" | jq -r '.changedFiles')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$PR_DATA" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          echo "‚úÖ PR validated successfully"

      - name: Set commit status (pending)
        if: steps.validate-pr.outputs.skip != 'true'
        id: create-status
        run: |
          REPO="${{ inputs.repository }}"
          HEAD_SHA="${{ steps.validate-pr.outputs.head_sha }}"
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "üìù Setting commit status to pending for $HEAD_SHA..."

          gh api "repos/$REPO/statuses/$HEAD_SHA" \
            --method POST \
            -f state="pending" \
            -f target_url="$WORKFLOW_URL" \
            -f description="AI Code Review in progress..." \
            -f context="AI Code Review" || {
            echo "‚ö†Ô∏è Failed to set commit status"
          }

          echo "‚úÖ Commit status set to pending"

      - name: Install Kilo CLI
        if: steps.validate-pr.outputs.skip != 'true'
        run: |
          npm install -g @kilocode/cli
          echo "‚úÖ Kilo CLI installed: $(kilocode --version || echo 'version check not supported')"

      - name: Clone target repository
        if: steps.validate-pr.outputs.skip != 'true'
        run: |
          REPO="${{ inputs.repository }}"
          HEAD_BRANCH="${{ steps.validate-pr.outputs.head_branch }}"
          PR_NUMBER="${{ inputs.pr_number }}"

          echo "üì¶ Cloning $REPO (branch: $HEAD_BRANCH)..."
          gh repo clone "$REPO" target-repo
          cd target-repo
          gh pr checkout $PR_NUMBER
          # gh repo clone "$REPO" target-repo -- --branch "$HEAD_BRANCH" --depth 50
          echo "‚úÖ Repository cloned"

      - name: Get PR diff
        if: steps.validate-pr.outputs.skip != 'true'
        id: get-diff
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"

          echo "üìÑ Fetching PR diff..."
          gh pr diff "$PR_NUMBER" --repo "$REPO" > pr_diff.patch

          # Get diff stats
          DIFF_LINES=$(wc -l < pr_diff.patch)
          echo "üìä Diff size: $DIFF_LINES lines"

          # Check if diff is too large (>10000 lines)
          if [ "$DIFF_LINES" -gt 10000 ]; then
            echo "‚ö†Ô∏è Large diff detected ($DIFF_LINES lines). Review may be truncated."
            echo "large_diff=true" >> $GITHUB_OUTPUT
          else
            echo "large_diff=false" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ PR diff fetched"

      - name: Load shared prompt
        if: steps.validate-pr.outputs.skip != 'true'
        id: shared-prompt
        run: |
          PROMPT_FILE="run-actions/${{ env.SHARED_PROMPT_PATH }}"

          if [ -f "$PROMPT_FILE" ]; then
            echo "‚úÖ Shared prompt loaded from $PROMPT_FILE"
            cat "$PROMPT_FILE" > shared_prompt.md
          else
            echo "‚ö†Ô∏è Shared prompt not found at $PROMPT_FILE, using default"
            exit 1;
          fi

      - name: Load personalized prompt (if exists)
        if: steps.validate-pr.outputs.skip != 'true'
        id: personalized-prompt
        run: |
          PROMPT_FILE="target-repo/${{ env.PERSONALIZED_PROMPT_PATH }}"

          if [ -f "$PROMPT_FILE" ]; then
            echo "‚úÖ Personalized prompt found at $PROMPT_FILE"
            cat "$PROMPT_FILE" > personalized_prompt.md
            echo "has_personalized=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No personalized prompt found at $PROMPT_FILE"
            touch personalized_prompt.md
            echo "has_personalized=false" >> $GITHUB_OUTPUT
          fi

      - name: Prepare review prompt
        if: steps.validate-pr.outputs.skip != 'true'
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          PR_TITLE="${{ steps.validate-pr.outputs.pr_title }}"
          PR_AUTHOR="${{ steps.validate-pr.outputs.pr_author }}"
          HEAD_BRANCH="${{ steps.validate-pr.outputs.head_branch }}"
          BASE_BRANCH="${{ steps.validate-pr.outputs.base_branch }}"
          ADDITIONS="${{ steps.validate-pr.outputs.additions }}"
          DELETIONS="${{ steps.validate-pr.outputs.deletions }}"
          CHANGED_FILES="${{ steps.validate-pr.outputs.changed_files }}"
          REVIEW_STYLE="${{ inputs.review_style }}"
          HAS_PERSONALIZED="${{ steps.personalized-prompt.outputs.has_personalized }}"

          cat > review_prompt.md << EOF
          # Pull Request Review Task

          ## PR Information
          - **Repository**: $REPO
          - **PR Number**: #$PR_NUMBER
          - **Title**: $PR_TITLE
          - **Author**: @$PR_AUTHOR
          - **Branch**: $HEAD_BRANCH ‚Üí $BASE_BRANCH
          - **Changes**: +$ADDITIONS/-$DELETIONS in $CHANGED_FILES files
          - **Review Style**: $REVIEW_STYLE

          ## Shared Review Guidelines

          $(cat shared_prompt.md)

          EOF

          if [ "$HAS_PERSONALIZED" = "true" ]; then
            cat >> review_prompt.md << EOF

          ## Repository-Specific Guidelines

          $(cat personalized_prompt.md)

          EOF
          fi

          cat >> review_prompt.md << 'EOF'

          ## Your Task

          1. Review the PR diff below thoroughly
          2. Identify issues based on the guidelines above
          3. Provide your review in the specified format

          ## PR Diff

          ```diff
          EOF

          cat pr_diff.patch >> review_prompt.md

          echo '```' >> review_prompt.md

          echo "‚úÖ Review prompt prepared ($(wc -l < review_prompt.md) lines)"
          cat review_prompt.md
          echo "----"

      - name: Configure Kilo CLI
        if: steps.validate-pr.outputs.skip != 'true'
        run: |
          mkdir -p ~/.kilocode/cli

          # Configure Kilo CLI with API key
          cat > ~/.kilocode/cli/config.json << EOF
          {
            "version": "1.0.0",
            "mode": "code",
            "telemetry": false,
            "provider": "default",
            "providers": [
              {
                "id": "default",
                "provider": "kilocode",
                "kilocodeToken": "${{ secrets.KILO_API_KEY }}",
                "kilocodeModel": "$AI_MODEL"
              }
            ],
            "autoApproval": {
              "enabled": true
            }
          }
          EOF

          echo "‚úÖ Kilo CLI configured"

      - name: Run Kilo review
        if: steps.validate-pr.outputs.skip != 'true'
        id: kilo-review
        working-directory: target-repo
        run: |
          echo "ü§ñ Starting Kilo code review..."

          kilocode --auto --timeout 600 "$(cat ../review_prompt.md)" | tee ../kilo_output.log

          COMMENT_COUNT=0
          HAS_OVERVIEW=false
          HAS_COMMENTS=false

          if [ -f "pr-overview.md" ]; then
            cp pr-overview.md ../review_output.md
            echo "‚úÖ Review output saved to ../review_output.md"
            cat pr-overview.md
            echo "------------------------"
            HAS_OVERVIEW=true
          else
            echo "‚ùå No review output found"
            echo "No review output generated" > ../review_output.md
          fi

          if [ -f "pr-comments.json" ]; then
            # Validate JSON syntax first
            if jq empty pr-comments.json 2>/dev/null; then
              # Validate JSON schema structure
              SCHEMA_VALID=true

              # Check required top-level fields
              if ! jq -e '.source and .diagnostics' pr-comments.json >/dev/null 2>&1; then
                echo "‚ö†Ô∏è pr-comments.json missing required fields (source, diagnostics)"
                SCHEMA_VALID=false
              fi

              # Validate each diagnostic has required fields
              if [ "$SCHEMA_VALID" = "true" ]; then
                INVALID_DIAGS=$(jq '[.diagnostics[] | select(.message == null or .location == null or .location.path == null or .location.range == null or .location.range.start == null or .location.range.start.line == null)] | length' pr-comments.json 2>/dev/null || echo "999")
                if [ "$INVALID_DIAGS" != "0" ]; then
                  echo "‚ö†Ô∏è Found $INVALID_DIAGS diagnostic(s) with missing required fields (message, location.path, location.range.start.line)"
                  # Filter out invalid diagnostics instead of rejecting entirely
                  jq '{source: .source, diagnostics: [.diagnostics[] | select(.message != null and .location != null and .location.path != null and .location.range != null and .location.range.start != null and .location.range.start.line != null)]}' pr-comments.json > ../review_comments.json
                  echo "‚úÖ Filtered to valid diagnostics only"
                else
                  cp pr-comments.json ../review_comments.json
                fi
              else
                echo '{"source":{"name":"ai-code-review","url":"https://github.com/alaudadevops/run-actions"},"diagnostics":[]}' > ../review_comments.json
              fi

              echo "‚úÖ Review comments saved to ../review_comments.json"
              cat ../review_comments.json
              echo "------------------------"
              HAS_COMMENTS=true
              # Count diagnostics in the validated JSON
              COMMENT_COUNT=$(jq '.diagnostics | length' ../review_comments.json 2>/dev/null || echo "0")
              echo "üìä Found $COMMENT_COUNT valid review comments"
            else
              echo "‚ö†Ô∏è pr-comments.json is not valid JSON, skipping"
              echo '{"source":{"name":"ai-code-review","url":"https://github.com/alaudadevops/run-actions"},"diagnostics":[]}' > ../review_comments.json
              COMMENT_COUNT=0
            fi
          else
            echo "‚ùå No review comments found"
            echo '{"source":{"name":"ai-code-review","url":"https://github.com/alaudadevops/run-actions"},"diagnostics":[]}' > ../review_comments.json
            COMMENT_COUNT=0
          fi

          NUMBER_OF_CRITICAL_ISSUES=$(jq '[.diagnostics[] | select(.severity | IN("WARNING","CRITICAL","ERROR"))] | length' ../review_comments.json)


          echo "‚úÖ Kilo review completed"
          echo "üìÑ Review output saved ($(wc -l < ../review_output.md) lines)"
          echo "comment_count=$COMMENT_COUNT" >> $GITHUB_OUTPUT
          echo "warning_count=$NUMBER_OF_CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "has_overview=$HAS_OVERVIEW" >> $GITHUB_OUTPUT
          echo "has_comments=$HAS_COMMENTS" >> $GITHUB_OUTPUT

      - name: Delete existing inline comments
        if: steps.validate-pr.outputs.skip != 'true' && inputs.dry_run != true
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          MARKER="${{ env.INLINE_COMMENT_MARKER }}"

          echo "üóëÔ∏è Deleting existing AI review inline comments..."

          # Get all review comments on the PR
          COMMENTS=$(gh api "repos/$REPO/pulls/$PR_NUMBER/comments" --paginate 2>/dev/null || echo "[]")

          # Find and delete comments with our marker
          DELETED=0
          echo "$COMMENTS" | jq -r ".[] | select(.body | contains(\"$MARKER\")) | .id" | while read -r COMMENT_ID; do
            if [ -n "$COMMENT_ID" ] && [ "$COMMENT_ID" != "null" ]; then
              gh api "repos/$REPO/pulls/comments/$COMMENT_ID" --method DELETE 2>/dev/null && {
                echo "  Deleted comment $COMMENT_ID"
                DELETED=$((DELETED + 1))
              } || echo "  Failed to delete comment $COMMENT_ID"
            fi
          done

          echo "‚úÖ Cleanup complete"

      - name: Validate line numbers against diff
        if: steps.validate-pr.outputs.skip != 'true'
        run: |
          echo "üîç Validating diagnostic line numbers against PR diff..."

          if [ ! -f review_comments.json ] || [ ! -f pr_diff.patch ]; then
            echo "‚ÑπÔ∏è Missing review_comments.json or pr_diff.patch, skipping validation"
            exit 0
          fi

          # Extract valid line ranges from diff for each file
          # Format: file:start_line:end_line (for each hunk)
          extract_valid_lines() {
            local current_file=""
            local new_line=0
            local in_hunk=false

            while IFS= read -r line; do
              # Match diff file header: +++ b/path/to/file
              if [[ "$line" =~ ^\+\+\+[[:space:]]b/(.+)$ ]]; then
                current_file="${BASH_REMATCH[1]}"
                in_hunk=false
              # Match hunk header: @@ -old,count +new,count @@
              elif [[ "$line" =~ ^@@[[:space:]]-[0-9]+(,[0-9]+)?[[:space:]]\+([0-9]+)(,[0-9]+)?[[:space:]]@@ ]]; then
                new_line="${BASH_REMATCH[2]}"
                in_hunk=true
              elif [ "$in_hunk" = true ] && [ -n "$current_file" ]; then
                # Lines starting with + or space (not -) are valid in new file
                if [[ "$line" =~ ^[+\ ] ]]; then
                  echo "$current_file:$new_line"
                  ((new_line++))
                elif [[ "$line" =~ ^- ]]; then
                  # Removed line - don't increment new_line counter
                  :
                fi
              fi
            done < pr_diff.patch
          }

          # Build lookup of valid file:line combinations
          echo "üìÑ Extracting valid lines from diff..."
          VALID_LINES=$(extract_valid_lines | sort -u)
          VALID_LINES_FILE=$(mktemp)
          echo "$VALID_LINES" > "$VALID_LINES_FILE"
          VALID_COUNT=$(wc -l < "$VALID_LINES_FILE" | tr -d ' ')
          echo "  Found $VALID_COUNT valid file:line combinations"

          # Filter diagnostics to only those with valid line numbers
          echo "üîé Filtering diagnostics..."
          ORIGINAL_COUNT=$(jq '.diagnostics | length' review_comments.json)

          jq -c '.diagnostics[]' review_comments.json | while read -r diag; do
            FILE=$(echo "$diag" | jq -r '.location.path // empty')
            LINE=$(echo "$diag" | jq -r '.location.range.start.line // 0')

            if grep -q "^${FILE}:${LINE}$" "$VALID_LINES_FILE" 2>/dev/null; then
              echo "$diag"
            else
              echo "  ‚ö†Ô∏è Skipping invalid line: $FILE:$LINE (not in diff)" >&2
            fi
          done | jq -s '{source: {"name": "ai-code-review", "url": "https://github.com/alaudadevops/run-actions"}, diagnostics: .}' > review_comments_validated.json

          mv review_comments_validated.json review_comments.json
          rm -f "$VALID_LINES_FILE"

          FILTERED_COUNT=$(jq '.diagnostics | length' review_comments.json)
          REMOVED=$((ORIGINAL_COUNT - FILTERED_COUNT))

          if [ "$REMOVED" -gt 0 ]; then
            echo "‚ö†Ô∏è Removed $REMOVED diagnostic(s) with invalid line numbers"
          fi
          echo "‚úÖ Validation complete: $FILTERED_COUNT valid diagnostics remaining"

      - name: Post inline comments via GitHub API
        if: steps.validate-pr.outputs.skip != 'true' && inputs.dry_run != true
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          HEAD_SHA="${{ steps.validate-pr.outputs.head_sha }}"
          MARKER="${{ env.INLINE_COMMENT_MARKER }}"

          echo "üìù Posting inline comments via GitHub API..."

          if [ ! -f review_comments.json ]; then
            echo "‚ÑπÔ∏è No comments file found"
            exit 0
          fi

          # Validate JSON first
          if ! jq empty review_comments.json 2>/dev/null; then
            echo "‚ö†Ô∏è review_comments.json is not valid JSON, skipping"
            exit 0
          fi

          # Check if there are any diagnostics
          DIAG_COUNT=$(jq '.diagnostics | length' review_comments.json 2>/dev/null || echo "0")
          if [ "$DIAG_COUNT" = "0" ] || [ -z "$DIAG_COUNT" ]; then
            echo "‚ÑπÔ∏è No diagnostics to post"
            exit 0
          fi

          echo "üìä Posting $DIAG_COUNT inline comments..."

          # Read and post each diagnostic as a review comment
          jq -c '.diagnostics[]' review_comments.json 2>/dev/null | while read -r diag; do
            FILE=$(echo "$diag" | jq -r '.location.path // empty')
            LINE=$(echo "$diag" | jq -r '.location.range.start.line // 1')
            MESSAGE=$(echo "$diag" | jq -r '.message // empty')
            SEVERITY=$(echo "$diag" | jq -r '.severity // "INFO"')
            CODE=$(echo "$diag" | jq -r '.code.value // empty')

            # Skip if essential fields are missing
            if [ -z "$FILE" ] || [ -z "$MESSAGE" ]; then
              echo "  ‚ö†Ô∏è Skipping invalid diagnostic (missing file or message)"
              continue
            fi

            # Format the comment body with marker for future cleanup
            if [ -n "$CODE" ]; then
              BODY=$(printf "%s\n**[%s]** \`%s\`\n\n%s" "$MARKER" "$SEVERITY" "$CODE" "$MESSAGE")
            else
              BODY=$(printf "%s\n**[%s]**\n\n%s" "$MARKER" "$SEVERITY" "$MESSAGE")
            fi

            echo "  ‚Üí $FILE:$LINE [$SEVERITY]"

            # Create a review comment on the PR
            gh api "repos/$REPO/pulls/$PR_NUMBER/comments" \
              --method POST \
              -f body="$BODY" \
              -f commit_id="$HEAD_SHA" \
              -f path="$FILE" \
              -F line="$LINE" \
              -f side="RIGHT" 2>/dev/null || echo "    ‚ö†Ô∏è Failed to post (line may not be in diff)"
          done

          echo "‚úÖ Inline comments posted"

      - name: Post overview comment
        if: steps.validate-pr.outputs.skip != 'true' && inputs.dry_run != true
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          MODEL="$AI_MODEL"
          REVIEW_STYLE="${{ inputs.review_style }}"
          HAS_PERSONALIZED="${{ steps.personalized-prompt.outputs.has_personalized }}"
          COMMENT_COUNT="${{ steps.kilo-review.outputs.comment_count }}"
          WARNING_COUNT="${{ steps.kilo-review.outputs.warning_count }}"
          MARKER="${{ env.REVIEW_COMMENT_MARKER }}"
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "üìù Preparing overview comment..."

          # Create formatted review comment
          cat > formatted_review.md << EOF
          $MARKER

          ## ü§ñ AI Code Review

          | Property | Value |
          |----------|-------|
          | **Model** | \`$MODEL\` |
          | **Style** | $REVIEW_STYLE |
          | **Issues Found** | $COMMENT_COUNT |
          | **Warnings/Errors** | $WARNING_COUNT |
          | **Personalized Prompt** | $([ "$HAS_PERSONALIZED" = "true" ] && echo "‚úÖ Yes" || echo "‚ùå No") |
          | **Reviewed at** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |

          ---

          $(cat review_output.md)

          ---

          <details>
          <summary>‚ÑπÔ∏è About this review</summary>

          This review was automatically generated using the [\`run-actions\`]($WORKFLOW_URL) workflow.

          - **Shared prompt**: [\`${{ env.SHARED_PROMPT_PATH }}\`](https://github.com/alaudadevops/run-actions/blob/main/${{ env.SHARED_PROMPT_PATH }})
          $([ "$HAS_PERSONALIZED" = "true" ] && echo "- **Repository prompt**: \`${{ env.PERSONALIZED_PROMPT_PATH }}\`" || echo "- *No repository-specific prompt configured*")

          </details>
          EOF

          # Find existing comment with marker
          echo "üîç Looking for existing review comment..."
          COMMENTS=$(gh api "repos/$REPO/issues/$PR_NUMBER/comments" --paginate 2>/dev/null || echo "[]")
          COMMENT_ID=$(echo "$COMMENTS" | jq -r ".[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)

          if [ -n "$COMMENT_ID" ] && [ "$COMMENT_ID" != "null" ]; then
            echo "üìù Updating existing comment $COMMENT_ID..."
            gh api "repos/$REPO/issues/comments/$COMMENT_ID" \
              --method PATCH \
              -f body="$(cat formatted_review.md)"
            echo "‚úÖ Comment updated"
          else
            echo "üìù Creating new review comment..."
            gh pr comment "$PR_NUMBER" --repo "$REPO" --body-file formatted_review.md
            echo "‚úÖ Comment created"
          fi

      - name: Update commit status (completed)
        if: always() && steps.validate-pr.outputs.skip != 'true'
        run: |
          REPO="${{ inputs.repository }}"
          HEAD_SHA="${{ steps.validate-pr.outputs.head_sha }}"
          COMMENT_COUNT="${{ steps.kilo-review.outputs.comment_count }}"
          WARNING_COUNT="${{ steps.kilo-review.outputs.warning_count }}"

          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "üìù Updating commit status for $HEAD_SHA..."

          # Determine state based on comment count
          if [ -z "$WARNING_COUNT" ] || [ "$WARNING_COUNT" = "0" ]; then
            STATE="success"
            DESCRIPTION="No issues found"
          else
            STATE="failure"
            DESCRIPTION="Found $WARNING_COUNT warning or error issue(s)"
          fi

          # Check if the review step failed
          if [ "${{ steps.kilo-review.outcome }}" = "failure" ]; then
            STATE="error"
            DESCRIPTION="Review process failed"
          fi

          gh api "repos/$REPO/statuses/$HEAD_SHA" \
            --method POST \
            -f state="$STATE" \
            -f target_url="$WORKFLOW_URL" \
            -f description="$DESCRIPTION" \
            -f context="AI Code Review" || {
            echo "‚ö†Ô∏è Failed to update commit status"
          }

          echo "‚úÖ Commit status updated: $STATE - $DESCRIPTION"

      - name: Output review (dry run)
        if: steps.validate-pr.outputs.skip != 'true' && inputs.dry_run == true
        run: |
          echo "üîç DRY RUN MODE - Review output:"
          echo "================================"
          echo "## Overview:"
          cat review_output.md
          echo ""
          echo "## Inline Comments (JSON):"
          cat review_comments.json | jq .
          echo "================================"
          echo "‚ÑπÔ∏è In non-dry-run mode, this would be posted to the PR"

      - name: Generate step summary
        if: always()
        run: |
          REPO="${{ inputs.repository }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          SKIP="${{ steps.validate-pr.outputs.skip }}"
          DRY_RUN="${{ inputs.dry_run }}"
          COMMENT_COUNT="${{ steps.kilo-review.outputs.comment_count }}"
          MODEL="$AI_MODEL"
          REVIEW_STYLE="${{ inputs.review_style }}"

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # AI PR Review Summary

          | Property | Value |
          |----------|-------|
          | **Repository** | [$REPO](https://github.com/$REPO) |
          | **PR** | [#$PR_NUMBER](https://github.com/$REPO/pull/$PR_NUMBER) |
          | **Model** | \`$MODEL\` |
          | **Style** | $REVIEW_STYLE |
          | **Issues Found** | ${COMMENT_COUNT:-0} |
          | **Status** | $([ "$SKIP" = "true" ] && echo "‚è≠Ô∏è Skipped" || echo "‚úÖ Completed") |
          | **Mode** | $([ "$DRY_RUN" = "true" ] && echo "üîç Dry Run" || echo "üìù Live") |

          EOF

          if [ "$SKIP" != "true" ] && [ -f review_output.md ]; then
            echo "## Review Output" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat review_output.md >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$SKIP" != "true" ] && [ -f review_comments.json ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Inline Comments" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat review_comments.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
