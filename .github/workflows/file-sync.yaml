name: Sync files to org repositories

on:
  workflow_dispatch:
    inputs:
      config_file:
        description: "Config file path (relative to repo root)"
        required: false
        default: ".github/sync/config/sync-manage-pr-config.yaml"
        type: string
      dry_run:
        description: "Dry run mode (only check, do not create PRs)"
        required: false
        default: false
        type: boolean

jobs:
  sync-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Verify GitHub CLI
        run: gh --version

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.47.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          echo "âœ… yq installed: $(yq --version)"

      - name: Auth with GH CLI
        run: |
          echo -n "${{ secrets.TOKEN }}" | gh auth login --with-token

      - name: Load sync configuration
        id: load-config
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Config file $CONFIG_FILE not found"
            exit 1
          fi

          # Validate YAML
          if [[ "$CONFIG_FILE" == *.yaml ]]; then
            if ! yq eval . "$CONFIG_FILE" > /dev/null 2>&1; then
              echo "âŒ Invalid YAML in config file $CONFIG_FILE"
              exit 1
            fi
          else
            echo "âŒ Config file must have .yaml extension"
            exit 1
          fi

          echo "âœ… Config file loaded: $CONFIG_FILE"
          cat "$CONFIG_FILE"

      - name: List target repositories
        id: list-repos
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          # Get all repositories in organization first
          echo "ğŸ“‹ Getting all repositories in organization"
          # Get organization name from config
          ORG_NAME=$(yq eval '.org_name' "$CONFIG_FILE")
          if [ "$ORG_NAME" = "null" ] || [ -z "$ORG_NAME" ]; then
            echo "âŒ org_name must be specified in config file"
            exit 1
          fi

          # Check if we should skip public repos from config
          SKIP_PUBLIC=$(yq eval '.skip_public_repos' "$CONFIG_FILE")
          if [ "$SKIP_PUBLIC" = "null" ] || [ -z "$SKIP_PUBLIC" ]; then
            SKIP_PUBLIC="false"
          fi
          echo "ğŸ” Skip public repos setting: $SKIP_PUBLIC"

          if [ "$SKIP_PUBLIC" = "true" ]; then
            echo "ğŸ”’ Filtering out public repositories (configured in $CONFIG_FILE)"
            gh repo list "$ORG_NAME" --limit 1000 --json nameWithOwner,visibility \
              -q '.[] | select(.visibility != "PUBLIC") | .nameWithOwner' > all_repos.txt
          else
            gh repo list "$ORG_NAME" --limit 1000 --json nameWithOwner \
              -q '.[].nameWithOwner' > all_repos.txt
          fi
          echo "âœ… Repositories listed, total: $(wc -l < all_repos.txt)"

          # Filter repositories based on config
          if yq eval '.repositories' "$CONFIG_FILE" | grep -q '\S'; then
            echo "ğŸ“‹ Filtering repositories using YAML config"

            # Clear target repos file
            > repos.txt

            # Process each repository pattern from config
            yq eval '.repositories[]' "$CONFIG_FILE" | while IFS= read -r repo_pattern; do
              if [[ "$repo_pattern" == regex:* ]]; then
                # Remove 'regex:' prefix and use as regex pattern
                pattern="${repo_pattern#regex:}"
                echo "ğŸ” Matching repositories with regex: $pattern"

                # Find matching repositories using grep with regex
                grep -E "^$pattern$" all_repos.txt >> repos.txt || true
              else
                # Exact match
                echo "ğŸ¯ Adding exact match: $repo_pattern"
                echo "$repo_pattern" >> repos.txt
              fi
            done
          else
            echo "ğŸ“‹ Using all repositories in organization"
            cp all_repos.txt repos.txt
          fi

          # Remove duplicates and empty lines
          sort repos.txt | uniq | grep -v '^$' > repos_final.txt || touch repos_final.txt
          mv repos_final.txt repos.txt

          echo "Target $(wc -l < repos.txt) repositories:"
          cat repos.txt

      - name: Get target branches
        id: get-branches
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"
          # Get target branches from config, default to "default" if not specified
          TARGET_BRANCHES=$(yq eval '.target_branches // "default"' "$CONFIG_FILE")
          echo "ğŸ“‹ Target branches from config: $TARGET_BRANCHES"
          echo "branches=$TARGET_BRANCHES" >> $GITHUB_OUTPUT

      - name: Clone source repositories
        id: clone-sources
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          # Create directory for source repositories
          mkdir -p source-repos

          # Track unique source repositories to avoid duplicate clones
          declare -A cloned_repos

          # Parse all files and identify unique source repositories
          file_count=$(yq eval '.files | length' "$CONFIG_FILE")
          for ((i=0; i<file_count; i++)); do
            source_repo=$(yq eval ".files[$i].source_repo // \"current\"" "$CONFIG_FILE")
            source_branch=$(yq eval ".files[$i].source_branch // \"main\"" "$CONFIG_FILE")

            if [ "$source_repo" != "current" ]; then
              repo_key="${source_repo}_${source_branch}"
              if [[ ! ${cloned_repos[$repo_key]+_} ]]; then
                echo "ğŸ”„ Cloning source repository: $source_repo (branch: $source_branch)"
                clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                git clone --quiet --depth 1 --branch "$source_branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$source_repo.git" "$clone_dir"
                cloned_repos[$repo_key]="$clone_dir"
                echo "âœ… Cloned $source_repo:$source_branch to $clone_dir"
              else
                echo "âš¡ Repository $source_repo:$source_branch already cloned"
              fi
            fi
          done

          echo "source_repos_cloned=true" >> $GITHUB_OUTPUT

      - name: Sync files to repositories
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"
          TARGET_BRANCHES="${{ steps.get-branches.outputs.branches }}"
          DRY_RUN="${{ inputs.dry_run }}"

          # Parse file mappings from config using yq

          while read -r repo; do
            [ -z "$repo" ] && continue
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ›ï¸  Processing repository: $repo"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Get all branches for this repo
            all_branches=$(gh api "repos/$repo/branches" --jq '.[].name' | tr '\n' ' ')
            default_branch=$(gh repo view "$repo" --json defaultBranchRef -q '.defaultBranchRef.name')

            echo "ğŸ“‹ Available branches in $repo: $all_branches"
            echo "ğŸŒŸ Default branch: $default_branch"

            # Determine target branches for this repo
            if [ "$TARGET_BRANCHES" = "default" ]; then
              target_branches="$default_branch"
            else
              target_branches=""
              IFS=',' read -ra BRANCH_PATTERNS <<< "$TARGET_BRANCHES"
              for pattern in "${BRANCH_PATTERNS[@]}"; do
                pattern=$(echo "$pattern" | xargs) # trim whitespace

                # Check if pattern is 'default' - use repo's default branch
                if [[ "$pattern" == "default" ]]; then
                  echo "ğŸ”§ Using default branch for: '$pattern' -> '$default_branch'"
                  target_branches="$target_branches $default_branch"
                else
                  # Use grep extended regex for all pattern matching
                  echo "ğŸ”§ Using grep regex matching for: '$pattern'"
                  matched_branches=$(echo "$all_branches" | tr ' ' '\n' | grep -E "^${pattern}$" || true)

                  if [ -n "$matched_branches" ]; then
                    while IFS= read -r matched_branch; do
                      if [ -n "$matched_branch" ]; then
                        echo "âœ… Branch '$matched_branch' matches regex pattern '$pattern'"
                        target_branches="$target_branches $matched_branch"
                      fi
                    done <<< "$matched_branches"
                  fi

                  # Check if no matches were found
                  if [ -z "$matched_branches" ]; then
                    echo "â„¹ï¸ No branches match regex pattern '$pattern'"
                  fi
                fi
              done
            fi

            echo "Target branches for $repo: $target_branches"

            # Process each target branch
            for branch in $target_branches; do
              [ -z "$branch" ] && continue
              echo "ğŸ“ Processing branch: $branch in $repo"

              needs_pr=false

              # Check each file from config
              file_count=$(yq eval '.files | length' "$CONFIG_FILE")
              for ((i=0; i<file_count; i++)); do
                source_path=$(yq eval ".files[$i].source" "$CONFIG_FILE")
                target_path=$(yq eval ".files[$i].target" "$CONFIG_FILE")
                source_repo=$(yq eval ".files[$i].source_repo // \"current\"" "$CONFIG_FILE")
                source_branch=$(yq eval ".files[$i].source_branch // \"main\"" "$CONFIG_FILE")

                # Determine actual source file path
                if [ "$source_repo" = "current" ]; then
                  actual_source_path="$source_path"
                else
                  clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                  actual_source_path="$clone_dir/$source_path"
                fi

                if [ ! -f "$actual_source_path" ]; then
                  echo "âš ï¸ Source file $actual_source_path not found (repo: $source_repo, branch: $source_branch), skipping"
                  continue
                fi

                # Check if file exists in target repo
                if gh api "repos/$repo/contents/$target_path?ref=$branch" >/dev/null 2>&1; then
                  # File exists, check if content differs
                  remote_content=$(gh api "repos/$repo/contents/$target_path?ref=$branch" --jq '.content' | base64 -d)
                  local_content=$(cat "$actual_source_path")

                  if [ "$remote_content" != "$local_content" ]; then
                    echo "ğŸ”„ File $target_path differs in $repo:$branch (source: $source_repo:$source_branch)"
                    needs_pr=true
                  else
                    echo "âœ… File $target_path is up to date in $repo:$branch"
                  fi
                else
                  echo "â• File $target_path missing in $repo:$branch (source: $source_repo:$source_branch)"
                  needs_pr=true
                fi
              done

              # If no files need updating, skip PR creation
              if [ "$needs_pr" = "false" ]; then
                continue
              fi

              # Create PR

              # Get PR title from config
              pr_title=$(yq eval '.pr_title // "chore: sync files to branch"' "$CONFIG_FILE")
              expected_pr_title="$pr_title \`$branch\`"

              # Check for existing PR with exact same title
              existing_pr=$(gh pr list --repo "$repo" --base "$branch" --state open --search "$pr_title" --json number,headRefName,title | jq --arg title "$expected_pr_title" 'map(select(.title == $title)) | .[0] // empty')
              pr_exists=$(echo "$existing_pr" | jq -r 'if . == null or . == "" then "0" else "1" end' 2>/dev/null || echo "0")
              pr_needs_update=true
              pr_number=""

              if [ "$pr_exists" = "1" ]; then
                pr_number=$(echo "$existing_pr" | jq -r '.number')
                pr_branch=$(echo "$existing_pr" | jq -r '.headRefName')

                # Check if PR content needs updating by comparing files
                echo "ğŸ” Checking if PR #$pr_number content needs updating..."

                # Assume PR is up to date unless we find differences
                pr_needs_update=false

                # Check each file to see if it differs from what's in the PR branch
                file_count=$(yq eval '.files | length' "$CONFIG_FILE")
                for ((k=0; k<file_count; k++)); do
                  source_path=$(yq eval ".files[$k].source" "$CONFIG_FILE")
                  target_path=$(yq eval ".files[$k].target" "$CONFIG_FILE")
                  source_repo=$(yq eval ".files[$k].source_repo // \"current\"" "$CONFIG_FILE")
                  source_branch_check=$(yq eval ".files[$k].source_branch // \"main\"" "$CONFIG_FILE")

                  echo "  ğŸ” Comparing $target_path..."

                  # Get current source content
                  if [ "$source_repo" = "current" ]; then
                    current_source_path="$source_path"
                  else
                    clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch_check}"
                    current_source_path="$clone_dir/$source_path"
                  fi

                  if [ -f "$current_source_path" ]; then
                    current_content=$(cat "$current_source_path")

                    # Get content from PR branch with better error handling
                    if pr_content=$(gh api "repos/$repo/contents/$target_path?ref=$pr_branch" --jq '.content' 2>/dev/null | base64 -d 2>/dev/null); then
                      if [ "$current_content" != "$pr_content" ]; then
                        echo "    ğŸ“ Content differs"
                        pr_needs_update=true
                        break
                      else
                        echo "    âœ… Content identical"
                      fi
                    else
                      echo "    ğŸ“ File missing in PR branch"
                      pr_needs_update=true
                      break
                    fi
                  else
                    echo "    âš ï¸ Source file not found: $current_source_path"
                    pr_needs_update=true
                    break
                  fi
                done

                if [ "$pr_needs_update" = "false" ]; then
                  echo "â„¹ï¸ PR #$pr_number content is already up to date for $repo:$branch"
                elif [ "$DRY_RUN" = "true" ]; then
                  echo "ğŸŸ¡ [DRY RUN] Would update existing PR #$pr_number for $repo:$branch"
                else
                  echo "ğŸ”„ Found existing PR #$pr_number with same title, updating content for $repo:$branch"

                  tmpdir=$(mktemp -d)
                  git clone --quiet --depth 1 --branch "$branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$repo.git" "$tmpdir"

                  cd "$tmpdir" || exit

                  # Fetch and checkout the existing PR branch
                  git fetch origin "$pr_branch"
                  git checkout "$pr_branch"

                  # Reset to base branch to get clean state
                  git reset --hard "origin/$branch"
                fi
              else
                # No existing PR, so we need to create one (pr_needs_update already true)
                if [ "$DRY_RUN" = "true" ]; then
                  echo "ğŸŸ¡ [DRY RUN] Would create new PR for $repo:$branch"
                else
                  echo "ğŸš€ Creating new PR for $repo:$branch"

                  tmpdir=$(mktemp -d)
                  git clone --quiet --depth 1 --branch "$branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$repo.git" "$tmpdir"

                  cd "$tmpdir" || exit

                  # Use consistent branch naming
                  sync_branch="sync-files-$(echo "$branch" | sed 's/[^a-zA-Z0-9._-]/-/g')"
                  git checkout -b "$sync_branch"
                fi
              fi

              # Copy files (skip in dry run mode or if PR doesn't need update)
              if [ "$DRY_RUN" != "true" ] && [ "$pr_needs_update" = "true" ]; then
                file_count=$(yq eval '.files | length' "$GITHUB_WORKSPACE/$CONFIG_FILE")
                for ((j=0; j<file_count; j++)); do
                  source_path=$(yq eval ".files[$j].source" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  target_path=$(yq eval ".files[$j].target" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  source_repo=$(yq eval ".files[$j].source_repo // \"current\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  source_branch=$(yq eval ".files[$j].source_branch // \"main\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")

                  # Determine actual source file path
                  if [ "$source_repo" = "current" ]; then
                    actual_source_path="$GITHUB_WORKSPACE/$source_path"
                  else
                    clone_dir="$GITHUB_WORKSPACE/source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                    actual_source_path="$clone_dir/$source_path"
                  fi

                  if [ -f "$actual_source_path" ]; then
                    mkdir -p "$(dirname "$target_path")"
                    cp "$actual_source_path" "$target_path"
                    git add "$target_path"
                    echo "ğŸ“„ Copied $actual_source_path -> $target_path"
                  else
                    echo "âš ï¸ Source file $actual_source_path not found during copy, skipping"
                  fi
                done

              if git diff --staged --quiet; then
                echo "â„¹ï¸ No changes to commit for $repo:$branch"
              else
                # Get PR title from config or use default
                pr_title=$(yq eval '.pr_title // "chore: sync files to branch"' "$GITHUB_WORKSPACE/$CONFIG_FILE")

                # Generate file list for commit message and PR body
                files_list=""
                pr_files_detail=""
                file_count=$(yq eval '.files | length' "$GITHUB_WORKSPACE/$CONFIG_FILE")
                for ((k=0; k<file_count; k++)); do
                  target_file=$(yq eval ".files[$k].target" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  source_file=$(yq eval ".files[$k].source" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  source_repo_detail=$(yq eval ".files[$k].source_repo // \"current\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  source_branch_detail=$(yq eval ".files[$k].source_branch // \"main\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")

                  # Replace "current" with actual repo name
                  if [ "$source_repo_detail" = "current" ]; then
                    source_repo_detail="${{ github.repository }}"
                    source_branch_detail="${{ github.ref_name }}"
                  fi

                  files_list="$files_list- $target_file\n"
                  pr_files_detail="$pr_files_detail- \`$target_file\` â† \`$source_file\` from [\`$source_repo_detail\`](https://github.com/$source_repo_detail/blob/$source_branch_detail/$source_file)\n"
                done

                git -c user.name="github-actions[bot]" -c user.email="41898282+github-actions[bot]@users.noreply.github.com" \
                  commit -m "$(cat <<EOF
          $pr_title \`$branch\`

          Files synced:
            $(echo -e "$files_list")

          Auto-generated by sync workflow
          EOF
                  )"

                git push origin HEAD

                # Create PR only if it's a new branch, otherwise just push updates
                if [ "$pr_exists" = "0" ]; then
                  gh pr create --repo "$repo" \
                    --title "$pr_title \`$branch\`" \
                    --base "$branch" \
                    --head "$(git branch --show-current)" \
                    --body "$(cat <<EOF
          This PR syncs files from the central repository to ensure consistency across the organization.

          ## ğŸ“„ Files synchronized:
          $(echo -e "$pr_files_detail")

          ## ğŸ¯ Target information:
          - **Repository:** \`$repo\`
          - **Target branch:** \`$branch\`
          - **Workflow run:** [\`${{ github.repository }}\` #\`${{ github.run_number }}\`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## âš™ï¸ Sync configuration:
          - **Config file:** \`${{ inputs.config_file }}\`
          - **Triggered by:** @${{ github.actor }}
          - **Run ID:** \`${{ github.run_id }}\`

          ---
          ğŸ¤– This is an automated PR created by the [file sync workflow](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/.github/workflows/file-sync.yaml).
          EOF
                  )"

                  echo "âœ”ï¸ PR created for $repo:$branch"
                else
                  echo "âœ”ï¸ PR updated for $repo:$branch (PR #$pr_number)"
                fi

                cd - >/dev/null || exit
                rm -rf "$tmpdir"
              fi
            done
          done < repos.txt
