name: Sync files to org repositories

on:
  workflow_dispatch:
    inputs:
      config_file:
        description: "Config file path (relative to repo root)"
        required: false
        default: ".github/sync/config/sync-manage-pr-config.yaml"
        type: string
      repositories:
        description: "Override repositories from config (comma-separated, supports regex: prefix)"
        required: false
        default: "regex:AlaudaDevops/.*"
        type: string
      dry_run:
        description: "Dry run mode (only check, do not create PRs)"
        required: false
        default: false
        type: boolean

jobs:
  sync-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Verify GitHub CLI
        run: gh --version

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.47.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          echo "‚úÖ yq installed: $(yq --version)"

      - name: Auth with GH CLI
        run: |
          echo -n "${{ secrets.TOKEN }}" | gh auth login --with-token

      - name: Load sync configuration
        id: load-config
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "‚ùå Config file $CONFIG_FILE not found"
            exit 1
          fi

          # Validate YAML
          if [[ "$CONFIG_FILE" == *.yaml ]]; then
            if ! yq eval . "$CONFIG_FILE" > /dev/null 2>&1; then
              echo "‚ùå Invalid YAML in config file $CONFIG_FILE"
              exit 1
            fi
          else
            echo "‚ùå Config file must have .yaml extension"
            exit 1
          fi

          echo "‚úÖ Config file loaded: $CONFIG_FILE"
          cat "$CONFIG_FILE"

      - name: List target repositories
        id: list-repos
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          # Get all repositories in organization first
          echo "üìã Getting all repositories in organization"
          # Get organization name from config
          ORG_NAME=$(yq eval '.org_name' "$CONFIG_FILE")
          if [ "$ORG_NAME" = "null" ] || [ -z "$ORG_NAME" ]; then
            echo "‚ùå org_name must be specified in config file"
            exit 1
          fi

          # Check if we should skip public repos from config
          SKIP_PUBLIC=$(yq eval '.skip_public_repos' "$CONFIG_FILE")
          if [ "$SKIP_PUBLIC" = "null" ] || [ -z "$SKIP_PUBLIC" ]; then
            SKIP_PUBLIC="false"
          fi
          echo "üîç Skip public repos setting: $SKIP_PUBLIC"

          if [ "$SKIP_PUBLIC" = "true" ]; then
            echo "üîí Filtering out public and archived repositories (configured in $CONFIG_FILE)"
            gh repo list "$ORG_NAME" --limit 1000 --json nameWithOwner,visibility,isArchived \
              -q '.[] | select(.visibility != "PUBLIC" and .isArchived != true) | .nameWithOwner' > all_repos.txt
          else
            echo "üìã Filtering out archived repositories"
            gh repo list "$ORG_NAME" --limit 1000 --json nameWithOwner,isArchived \
              -q '.[] | select(.isArchived != true) | .nameWithOwner' > all_repos.txt
          fi
          echo "‚úÖ Repositories listed, total: $(wc -l < all_repos.txt)"

          # Filter repositories based on input parameter or config
          OVERRIDE_REPOS="${{ inputs.repositories }}"
          if [ -n "$OVERRIDE_REPOS" ]; then
            echo "üìã Using repositories from input parameter (overriding config): $OVERRIDE_REPOS"

            # Clear target repos file
            > repos.txt

            # Process each repository pattern from input parameter
            IFS=',' read -ra REPO_PATTERNS <<< "$OVERRIDE_REPOS"
            for repo_pattern in "${REPO_PATTERNS[@]}"; do
              repo_pattern=$(echo "$repo_pattern" | xargs) # trim whitespace
              if [[ "$repo_pattern" == regex:* ]]; then
                # Remove 'regex:' prefix and use as regex pattern
                pattern="${repo_pattern#regex:}"
                echo "üîç Matching repositories with regex: $pattern"

                # Find matching repositories using grep with regex
                grep -E "^$pattern$" all_repos.txt >> repos.txt || true
              else
                # Exact match
                echo "üéØ Adding exact match: $repo_pattern"
                echo "$repo_pattern" >> repos.txt
              fi
            done
          elif yq eval '.repositories' "$CONFIG_FILE" | grep -q '\S'; then
            echo "üìã Filtering repositories using YAML config"

            # Clear target repos file
            > repos.txt

            # Process each repository pattern from config
            yq eval '.repositories[]' "$CONFIG_FILE" | while IFS= read -r repo_pattern; do
              if [[ "$repo_pattern" == regex:* ]]; then
                # Remove 'regex:' prefix and use as regex pattern
                pattern="${repo_pattern#regex:}"
                echo "üîç Matching repositories with regex: $pattern"

                # Find matching repositories using grep with regex
                grep -E "^$pattern$" all_repos.txt >> repos.txt || true
              else
                # Exact match
                echo "üéØ Adding exact match: $repo_pattern"
                echo "$repo_pattern" >> repos.txt
              fi
            done
          else
            echo "üìã Using all repositories in organization"
            cp all_repos.txt repos.txt
          fi

          # Remove duplicates and empty lines
          sort repos.txt | uniq | grep -v '^$' > repos_final.txt || touch repos_final.txt
          mv repos_final.txt repos.txt

          echo "Target $(wc -l < repos.txt) repositories:"
          cat repos.txt

      - name: Get target branches
        id: get-branches
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"
          # Get target branches from config, default to "default" if not specified
          TARGET_BRANCHES=$(yq eval '.target_branches // "default"' "$CONFIG_FILE")
          echo "üìã Target branches from config: $TARGET_BRANCHES"
          echo "branches=$TARGET_BRANCHES" >> $GITHUB_OUTPUT

      - name: Clone source repositories
        id: clone-sources
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"

          # Create directory for source repositories
          mkdir -p source-repos

          # Track unique source repositories to avoid duplicate clones
          declare -A cloned_repos

          # Parse all files and identify unique source repositories
          file_count=$(yq eval '.files | length' "$CONFIG_FILE")
          for ((i=0; i<file_count; i++)); do
            source_repo=$(yq eval ".files[$i].source_repo // \"current\"" "$CONFIG_FILE")
            source_branch=$(yq eval ".files[$i].source_branch // \"main\"" "$CONFIG_FILE")

            if [ "$source_repo" != "current" ]; then
              repo_key="${source_repo}_${source_branch}"
              if [[ ! ${cloned_repos[$repo_key]+_} ]]; then
                echo "üîÑ Cloning source repository: $source_repo (branch: $source_branch)"
                clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                git clone --quiet --depth 1 --branch "$source_branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$source_repo.git" "$clone_dir"
                cloned_repos[$repo_key]="$clone_dir"
                echo "‚úÖ Cloned $source_repo:$source_branch to $clone_dir"
              else
                echo "‚ö° Repository $source_repo:$source_branch already cloned"
              fi
            fi
          done

          echo "source_repos_cloned=true" >> $GITHUB_OUTPUT

      - name: Sync files to repositories
        run: |
          CONFIG_FILE="${{ inputs.config_file }}"
          TARGET_BRANCHES="${{ steps.get-branches.outputs.branches }}"
          DRY_RUN="${{ inputs.dry_run }}"

          # Initialize statistics counters
          pr_created=0
          pr_updated=0
          pr_skipped=0
          repos_processed=0

          # Dry run specific counters
          dry_run_would_create=0
          dry_run_would_update=0

          # Generate PR body function
          generate_pr_body() {
            local repo="$1"
            local branch="$2"
            local pr_files_detail="$3"
            cat <<EOF
          This PR syncs files from the central repository to ensure consistency across the organization.

          ## üìÑ Files synchronized:
          $(echo -e "$pr_files_detail")

          ## üéØ Target information:
          - **Repository:** \`$repo\`
          - **Target branch:** \`$branch\`
          - **Workflow run:** [\`${{ github.repository }}\` #\`${{ github.run_number }}\`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## ‚öôÔ∏è Sync configuration:
          - **Config file:** \`${{ inputs.config_file }}\`
          - **Triggered by:** @${{ github.actor }}
          - **Run ID:** \`${{ github.run_id }}\`

          ---
          ü§ñ This is an automated PR created by the [file sync workflow](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/.github/workflows/file-sync.yaml).
          EOF
          }

          # Generate commit message
          generate_commit_message() {
            local pr_title="$1"
            local branch="$2"
            local files_list="$3"
            cat <<EOF
          $pr_title \`$branch\`

          Files synced:
          $(echo -e "$files_list")

          Auto-generated by sync workflow
          EOF
          }

          # Parse file mappings from config using yq

          while read -r repo; do
            [ -z "$repo" ] && continue
            repos_processed=$((repos_processed + 1))
            echo ""
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "üèõÔ∏è  Processing repository: $repo ($repos_processed)"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

            # Get all branches for this repo
            all_branches=$(gh api "repos/$repo/branches" --jq '.[].name' | tr '\n' ' ')
            default_branch=$(gh repo view "$repo" --json defaultBranchRef -q '.defaultBranchRef.name')

            echo "üìã Available branches in $repo: $all_branches"
            echo "üåü Default branch: $default_branch"

            # Determine target branches for this repo
            if [ "$TARGET_BRANCHES" = "default" ]; then
              target_branches="$default_branch"
            else
              target_branches=""
              IFS=',' read -ra BRANCH_PATTERNS <<< "$TARGET_BRANCHES"
              for pattern in "${BRANCH_PATTERNS[@]}"; do
                pattern=$(echo "$pattern" | xargs) # trim whitespace

                # Check if pattern is 'default' - use repo's default branch
                if [[ "$pattern" == "default" ]]; then
                  echo "  üîß Using default branch for: '$pattern' -> '$default_branch'"
                  target_branches="$target_branches $default_branch"
                else
                  # Use grep extended regex for all pattern matching
                  echo "  üîß Using grep regex matching for: '$pattern'"
                  matched_branches=$(echo "$all_branches" | tr ' ' '\n' | grep -E "^${pattern}$" || true)

                  if [ -n "$matched_branches" ]; then
                    while IFS= read -r matched_branch; do
                      if [ -n "$matched_branch" ]; then
                        echo "    üëå Branch '$matched_branch' matches regex pattern '$pattern'"
                        target_branches="$target_branches $matched_branch"
                      fi
                    done <<< "$matched_branches"
                  fi

                  # Check if no matches were found
                  if [ -z "$matched_branches" ]; then
                    echo "    ‚ùå No branches match regex pattern '$pattern'"
                  fi
                fi
              done
            fi

            echo "üéØ Target branches for $repo: $target_branches"

            # Process each target branch
            for branch in $target_branches; do
              [ -z "$branch" ] && continue
              echo ""
              echo "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
              echo "  üìù Processing branch: $branch"
              echo "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

              needs_pr=false

              # Check each file from config
              file_count=$(yq eval '.files | length' "$CONFIG_FILE")
              for ((i=0; i<file_count; i++)); do
                source_path=$(yq eval ".files[$i].source" "$CONFIG_FILE")
                target_path=$(yq eval ".files[$i].target" "$CONFIG_FILE")
                source_repo=$(yq eval ".files[$i].source_repo // \"current\"" "$CONFIG_FILE")
                source_branch=$(yq eval ".files[$i].source_branch // \"main\"" "$CONFIG_FILE")

                # Determine actual source file path
                if [ "$source_repo" = "current" ]; then
                  actual_source_path="$source_path"
                else
                  clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                  actual_source_path="$clone_dir/$source_path"
                fi

                if [ ! -f "$actual_source_path" ]; then
                  echo "    ‚ö†Ô∏è Source file $actual_source_path not found (repo: $source_repo, branch: $source_branch), skipping"
                  continue
                fi

                # Check if file exists in target repo
                if gh api "repos/$repo/contents/$target_path?ref=$branch" >/dev/null 2>&1; then
                  # File exists, check if content differs
                  remote_content=$(gh api "repos/$repo/contents/$target_path?ref=$branch" --jq '.content' | base64 -d)
                  local_content=$(cat "$actual_source_path")

                  if [ "$remote_content" != "$local_content" ]; then
                    echo "    üîÑ File $target_path differs (source: $source_repo:$source_branch)"
                    needs_pr=true
                  else
                    echo "    ‚úÖ File $target_path is up to date"
                  fi
                else
                  echo "    ‚ûï File $target_path missing (source: $source_repo:$source_branch)"
                  needs_pr=true
                fi
              done

              # Create PR if needed
              if [ "$needs_pr" = "true" ]; then
                # Get PR title from config
                pr_title=$(yq eval '.pr_title // "chore: sync files to branch"' "$CONFIG_FILE")
                expected_pr_title="$pr_title \`$branch\`"

                # Check for existing PR with exact same title
                existing_pr=$(gh pr list --repo "$repo" --base "$branch" --state open --search "$pr_title" --json number,headRefName,title | jq --arg title "$expected_pr_title" 'map(select(.title == $title)) | .[0] // empty')
                pr_exists=$(echo "$existing_pr" | jq -r 'if . == null or . == "" or . == "empty" then "0" else "1" end' 2>/dev/null || echo "0")
                # Ensure pr_exists is always a valid number
                if [[ ! "$pr_exists" =~ ^[0-9]+$ ]]; then
                  echo "    ‚ö†Ô∏è Warning: Unable to determine if PR exists ${pr_exists}, assuming no existing PR"
                  pr_exists="0"
                fi
                pr_needs_update=true
                pr_number=""
                tmpdir=""

                if [ "$pr_exists" -gt 0 ]; then
                  pr_number=$(echo "$existing_pr" | jq -r '.number')
                  pr_branch=$(echo "$existing_pr" | jq -r '.headRefName')

                  # Check if PR content needs updating by comparing files
                  echo "    üîç Checking if PR #$pr_number content needs updating..."

                  # Assume PR is up to date unless we find differences
                  pr_needs_update=false

                  # Check each file to see if it differs from what's in the PR branch
                  file_count=$(yq eval '.files | length' "$CONFIG_FILE")
                  for ((k=0; k<file_count; k++)); do
                    source_path=$(yq eval ".files[$k].source" "$CONFIG_FILE")
                    target_path=$(yq eval ".files[$k].target" "$CONFIG_FILE")
                    source_repo=$(yq eval ".files[$k].source_repo // \"current\"" "$CONFIG_FILE")
                    source_branch_check=$(yq eval ".files[$k].source_branch // \"main\"" "$CONFIG_FILE")

                    echo "      üîé Comparing $target_path..."

                    # Get current source content
                    if [ "$source_repo" = "current" ]; then
                      current_source_path="$source_path"
                    else
                      clone_dir="source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch_check}"
                      current_source_path="$clone_dir/$source_path"
                    fi

                    if [ -f "$current_source_path" ]; then
                      current_content=$(cat "$current_source_path")

                      # Get content from PR branch with better error handling
                      if pr_content=$(gh api "repos/$repo/contents/$target_path?ref=$pr_branch" --jq '.content' 2>/dev/null | base64 -d 2>/dev/null); then
                        if [ "$current_content" != "$pr_content" ]; then
                          echo "        üìù Content differs"
                          pr_needs_update=true
                          break
                        else
                          echo "        ‚úÖ Content identical"
                        fi
                      else
                        echo "        üìù File missing in PR branch"
                        pr_needs_update=true
                        break
                      fi
                    else
                      echo "        ‚ö†Ô∏è Source file not found: $current_source_path"
                      pr_needs_update=true
                      break
                    fi
                  done

                  if [ "$pr_needs_update" = "false" ]; then
                    echo "    ‚úÖ PR #$pr_number content is already up to date - PR: https://github.com/$repo/pull/$pr_number"
                    pr_skipped=$((pr_skipped + 1))
                  elif [ "$DRY_RUN" = "true" ]; then
                    echo "    üü° [DRY RUN] Would update existing PR #$pr_number"
                    dry_run_would_update=$((dry_run_would_update + 1))
                  else
                    echo "    üîÑ Found existing PR #$pr_number with same title, updating content..."

                    tmpdir=$(mktemp -d)
                    git clone --quiet --depth 1 --branch "$branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$repo.git" "$tmpdir"

                    cd "$tmpdir" || exit

                    # Fetch and checkout the existing PR branch
                    git fetch origin "$pr_branch:$pr_branch"
                    git checkout "$pr_branch"

                    # Reset to base branch to get clean state and preserve branch reference
                    git reset --hard "origin/$branch"

                  fi
                else
                  # No existing PR, so we need to create one (pr_needs_update already true)
                  if [ "$DRY_RUN" = "true" ]; then
                    echo "    üü° [DRY RUN] Would create new PR"
                    dry_run_would_create=$((dry_run_would_create + 1))
                  else
                    echo "    üöÄ Creating new PR..."

                    tmpdir=$(mktemp -d)
                    git clone --quiet --depth 1 --branch "$branch" "https://x-access-token:${{ secrets.TOKEN }}@github.com/$repo.git" "$tmpdir"

                    cd "$tmpdir" || exit

                    # Generate unique branch name based on config file hash to avoid conflicts
                    config_hash=$(md5sum "$GITHUB_WORKSPACE/$CONFIG_FILE" | cut -c1-8)
                    sync_branch="sync-files-$(echo "$branch" | sed 's/[^a-zA-Z0-9._-]/-/g')-${config_hash}"
                    git checkout -b "$sync_branch"
                  fi
                fi

                # Copy files (skip in dry run mode or if PR doesn't need update)
                if [ "$DRY_RUN" != "true" ] && [ "$pr_needs_update" = "true" ]; then
                  file_count=$(yq eval '.files | length' "$GITHUB_WORKSPACE/$CONFIG_FILE")
                  for ((j=0; j<file_count; j++)); do
                    source_path=$(yq eval ".files[$j].source" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                    target_path=$(yq eval ".files[$j].target" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                    source_repo=$(yq eval ".files[$j].source_repo // \"current\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                    source_branch=$(yq eval ".files[$j].source_branch // \"main\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")

                    # Determine actual source file path
                    if [ "$source_repo" = "current" ]; then
                      actual_source_path="$GITHUB_WORKSPACE/$source_path"
                    else
                      clone_dir="$GITHUB_WORKSPACE/source-repos/$(echo "$source_repo" | sed 's/\//_/g')_${source_branch}"
                      actual_source_path="$clone_dir/$source_path"
                    fi

                    if [ -f "$actual_source_path" ]; then
                      mkdir -p "$(dirname "$target_path")"
                      cp "$actual_source_path" "$target_path"
                      git add "$target_path"
                      echo "      üìÑ Copied $actual_source_path -> $target_path"
                    else
                      echo "      ‚ö†Ô∏è Source file $actual_source_path not found during copy, skipping"
                    fi
                  done

                  if git diff --staged --quiet; then
                    echo "    ‚úÖ No changes to commit"
                  else
                    # Get PR title from config or use default
                    pr_title=$(yq eval '.pr_title // "chore: sync files to branch"' "$GITHUB_WORKSPACE/$CONFIG_FILE")

                    # Generate file list for commit message and PR body
                    files_list=""
                    pr_files_detail=""
                    file_count=$(yq eval '.files | length' "$GITHUB_WORKSPACE/$CONFIG_FILE")
                    for ((k=0; k<file_count; k++)); do
                      target_file=$(yq eval ".files[$k].target" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                      source_file=$(yq eval ".files[$k].source" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                      source_repo_detail=$(yq eval ".files[$k].source_repo // \"current\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")
                      source_branch_detail=$(yq eval ".files[$k].source_branch // \"main\"" "$GITHUB_WORKSPACE/$CONFIG_FILE")

                      # Replace "current" with actual repo name
                      if [ "$source_repo_detail" = "current" ]; then
                        source_repo_detail="${{ github.repository }}"
                        source_branch_detail="${{ github.ref_name }}"
                      fi

                      files_list="$files_list- $target_file\n"
                      pr_files_detail="$pr_files_detail- \`$target_file\` ‚Üê \`$source_file\` from [\`$source_repo_detail\`](https://github.com/$source_repo_detail/blob/$source_branch_detail/$source_file)\n"
                    done

                    git -c user.name="github-actions[bot]" -c user.email="41898282+github-actions[bot]@users.noreply.github.com" \
                      commit -m "$(generate_commit_message "$pr_title" "$branch" "$files_list")"

                    git push --force origin HEAD

                    # Create PR only if it's a new branch, otherwise just push updates
                    if [ "$pr_exists" -eq 0 ]; then
                      gh pr create --repo "$repo" \
                        --title "$pr_title \`$branch\`" \
                        --base "$branch" \
                        --head "$(git branch --show-current)" \
                        --body "$(generate_pr_body "$repo" "$branch" "$pr_files_detail")"

                      echo "    ‚úîÔ∏è PR created successfully"
                      pr_created=$((pr_created + 1))
                    else
                      echo "    ‚úîÔ∏è PR updated successfully (PR #$pr_number)"
                      pr_updated=$((pr_updated + 1))
                    fi
                  fi

                  if [ -n "$tmpdir" ]; then
                    cd - >/dev/null || exit
                    rm -rf "$tmpdir"
                  fi
                fi
              else
                echo "    ‚úÖ No changes needed - all files up to date"
                pr_skipped=$((pr_skipped + 1))
              fi
            done
          done < repos.txt

          # Display final statistics
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä SYNC STATISTICS SUMMARY"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üì¶ Repositories processed: $repos_processed"

          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "üü° DRY RUN MODE - Simulation Results:"
            echo "üöÄ PRs that would be created: $dry_run_would_create"
            echo "üîÑ PRs that would be updated: $dry_run_would_update"
            echo "‚è≠Ô∏è PRs skipped (up to date): $pr_skipped"
            echo "üìà Total PR actions planned: $((dry_run_would_create + dry_run_would_update + pr_skipped))"
            echo ""
            echo "üü° Note: This was a dry run - no actual PRs were created or modified"
          else
            echo "üöÄ PRs created: $pr_created"
            echo "üîÑ PRs updated: $pr_updated"
            echo "‚è≠Ô∏è PRs skipped (up to date): $pr_skipped"
            echo "üìà Total PR actions: $((pr_created + pr_updated + pr_skipped))"
          fi
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
